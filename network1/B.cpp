#define  _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <tchar.h>
#include <WinSock2.h>
#include <Windows.h>

#include <stdlib.h>
#include <iostream>
#include <string>
#define HAVE_REMOTE

#include <pcap.h>
#include "tcp.h"
#pragma pack(1)  //按一个字节内存对齐
#define IPTOSBUFFERS    12
#define ETH_ARP         0x0806  //以太网帧类型表示后面数据的类型，对于ARP请求或应答来说，该字段的值为x0806
#define ARP_HARDWARE    1  //硬件类型字段值为表示以太网地址
#define ETH_IP          0x0800  //协议类型字段表示要映射的协议地址类型值为x0800表示IP地址
#define ARP_REQUEST     1
#define ARP_REPLY       2
#define HOSTNUM         255
void sendHello();
void receiveMessage();
unsigned char SendBuffer[200];
// 函数原型
void ifget(pcap_if_t *d, char *ip_addr, char *ip_netmask);
char *iptos(u_long in);
char* ip6tos(struct sockaddr *sockaddr, char *address, int addrlen);
int SendArp(pcap_t *adhandle, char *ip, unsigned char *mac);
int GetSelfMac(pcap_t *adhandle, const char *ip_addr, unsigned char *ip_mac);
DWORD WINAPI SendArpPacket(LPVOID lpParameter);
DWORD WINAPI GetLivePC(LPVOID lpParameter);
//14字节以太网帧结构
struct ethernet_head {
	unsigned char dest_mac_add[6];    //目的mac地址
	unsigned char source_mac_add[6]; //源mac地址
	unsigned short type;              //帧类型
};
ethernet_head * rec_eth_head;

struct IpHeader {
	unsigned char Version_HLen;              //1byte 版本类型
	unsigned char TOS;              //1byte 服务类型
	short Length;
	short Ident;
	short Flags_Offset;
	unsigned char TTL;
	unsigned char Protocol;
	short Checksum;
	unsigned int SourceAddr;
	unsigned int DestinationAddr;
};

struct TcpHeader {
	unsigned short SrcPort;	//2byte
	unsigned short DstPort;	//2byte
	unsigned int SequenceNum;			//4byte
	unsigned int Acknowledgment;	//4byte
	unsigned char HdrLen;			//1byte
	unsigned char Flags;			//1byte
	unsigned short AdvertisedWindow;		//2byte
	unsigned short Checksum;				//2byte
	unsigned short UrgPtr;						//2byte
};
//20byte

unsigned short checksum(unsigned short *data, int length) {
	unsigned long temp = 0;
	while (length > 1) {
		temp += *data++;
		length -= sizeof(unsigned short);
	}
	if (length) {
		temp += *(unsigned short*) data;
	}
	temp = (temp >> 16) + (temp & 0xffff);
	temp += (temp >> 16);
	return (unsigned short) (~temp);
}
//28字节ARP帧结构
struct arp_head {
	unsigned short hardware_type;    //硬件类型
	unsigned short protocol_type;    //协议类型
	unsigned char hardware_add_len; //硬件地址长度
	unsigned char protocol_add_len; //协议地址长度
	unsigned short operation_field; //操作字段
	unsigned char source_mac_add[6]; //源mac地址
	unsigned long source_ip_add;    //源ip地址
	unsigned char dest_mac_add[6]; //目的mac地址
	unsigned long dest_ip_add;      //目的ip地址
};
//arp最终包结构
struct arp_packet {
	struct ethernet_head ed;
	struct arp_head ah;
};
struct PsdTcpHeader {
	unsigned long SourceAddr;
	unsigned long DestinationAddr;
	char Zero;
	char Protcol;
	unsigned short TcpLen;
};

char TcpData[] = "Hello";
struct sparam {
	pcap_t *adhandle;
	char *ip;
	unsigned char *mac;
	char *netmask;
};
struct gparam {
	pcap_t *adhandle;
};
bool flag;
struct sparam sp;
struct gparam gp;
struct ethernet_head ethernet;
struct IpHeader ip;
struct TcpHeader tcp;
struct PsdTcpHeader ptcp;
HANDLE sendthread;
HANDLE recvthread;
/**记录扫描到的MAC和IP对应的信息*/
struct MacMapIP {
	unsigned char Mac[6];
	unsigned long IP[4];
} Machines[256];
int countMachine = 0;
//发送时的数据修改
char * sourIP;
char * destIP;
/**来记录是否是已经扫描完成了*/
boolean scanFinished = false;
/**机器本身的MAC*/
unsigned char selfMAC[6];
int Result;
pcap_t *adhandle, *adhandle2;

char *ip_addr;
char *ip_netmask;
unsigned char *ip_mac;
pcap_if_t *alldevs;
pcap_if_t *d;
int inum;
int cMacIP;

int i = 0;
char errbuf[PCAP_ERRBUF_SIZE];
u_int netmask;
char packet_filter[] = "tcp and(ether dst 74-E5-0B-F4-BD-07)"; //自己定义ip地址即可
struct bpf_program fcode;
int main() {
	/* 获取本机设备列表 */
	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1) {
		fprintf(stderr, "Error in pcap_findalldevs: %s\n", errbuf);
		exit(1);
	}

	/* 打印列表 */
	for (d = alldevs; d; d = d->next) {
		printf("%d. %s", ++i, d->name);
		if (d->description)
			printf(" (%s)\n", d->description);
		else
			printf(" (No description available)\n");
	}

	if (i == 0) {
		printf("\nNo interfaces found! Make sure WinPcap is installed.\n");
		return -1;
	}

	printf("Enter the interface number (1-%d):", i);
	scanf("%d", &inum);

	if (inum < 1 || inum > i) {
		printf("\nInterface number out of range.\n");
		/* 释放设备列表 */
		pcap_freealldevs(alldevs);
		return -1;
	}

	/* 跳转到选中的适配器 */
	for (d = alldevs, i = 0; i < inum - 1; d = d->next, i++);

	/* 打开设备 */
	if ((adhandle = pcap_open(d->name, // 设备名
			65535, // 65535保证能捕获到不同数据链路层上的每个数据包的全部内容
			PCAP_OPENFLAG_PROMISCUOUS, // 混杂模式
			1000, // 读取超时时间
			NULL, // 远程机器验证
			errbuf // 错误缓冲池
			)) == NULL) {
		fprintf(stderr,
				"\nUnable to open the adapter. %s is not supported by WinPcap\n",
				d->name);
		/* 释放设备列表 */
		pcap_freealldevs(alldevs);
		return -1;
	}

	printf("nlistening on %s...n", d->description);

	/* 检查数据链路层，为了简单，我们只考虑以太网 */
	if (pcap_datalink(adhandle) != DLT_EN10MB) {
		fprintf(stderr, "\nThis program works only on Ethernet networks.\n");
		/* 释放设备列表 */
		pcap_freealldevs(alldevs);
		return -1;
	}
	printf("datalink:[%d]\n", pcap_datalink(adhandle));

	if (d->addresses != NULL)
		/* 获得接口第一个地址的掩码 */
		netmask =
				((struct sockaddr_in *) (d->addresses->netmask))->sin_addr.S_un.S_addr;
	else
		/* 如果接口没有地址，那么我们假设一个C类的掩码 */
		netmask = 0xffffff;

	//编译过滤器
	if (pcap_compile(adhandle, &fcode, packet_filter, 1, netmask) < 0) {
		fprintf(stderr,
				"\nUnable to compile the packet filter. Check the syntax.\n");
		/* 释放设备列表 */
		pcap_freealldevs(alldevs);
		int x;
		scanf("%d", &x);
		return -1;
	}

	//设置过滤器
	if (pcap_setfilter(adhandle, &fcode) < 0) {
		fprintf(stderr, "\nError setting the filter.\n");
		/* 释放设备列表 */
		pcap_freealldevs(alldevs);
		return -1;
	}

	printf("nlistening on %s...\n", d->description);

	receiveMessage();


	/**以上是接收信息的功能*/

	pcap_freealldevs(alldevs);

//liebao
	inum = 4;
	/* 获取本机设备列表 */
		if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1) {
			fprintf(stderr, "Error in pcap_findalldevs: %s\n", errbuf);
			exit(1);
		}

	/* 跳转到选中的适配器 */
	for (d = alldevs, i = 0; i < inum - 1; d = d->next, i++)
		;
	ip_addr = (char *) malloc(sizeof(char) * 16); //申请内存存放IP地址
	if (ip_addr == NULL) {
		printf("申请内存存放IP地址失败!\n");
		return -1;
	}
	ip_netmask = (char *) malloc(sizeof(char) * 16); //申请内存存放NETMASK地址
	if (ip_netmask == NULL) {
		printf("申请内存存放NETMASK地址失败!\n");
		return -1;
	}
	ip_mac = (unsigned char *) malloc(sizeof(unsigned char) * 6); //申请内存存放MAC地址
	if (ip_mac == NULL) {
		printf("申请内存存放MAC地址失败!\n");
		return -1;
	}

	/* 打开设备 */
	if ((adhandle2 = pcap_open(d->name, // 设备名
			65535, // 65535保证能捕获到不同数据链路层上的每个数据包的全部内容
			PCAP_OPENFLAG_PROMISCUOUS, // 混杂模式
			1000, // 读取超时时间
			NULL, // 远程机器验证
			errbuf // 错误缓冲池
			)) == NULL) {
		fprintf(stderr,
				"\nUnable to open the adapter. %s is not supported by WinPcap\n",
				d->name);
		/* 释放设备列表 */
		pcap_freealldevs(alldevs);
		return -1;
	}

	printf("nlistening on %s...n", d->description);
	ifget(d, ip_addr, ip_netmask);            //获取所选网卡的基本信息--掩码--IP地址
	GetSelfMac(adhandle2, ip_addr, ip_mac);         //输入网卡设备句柄网卡设备ip地址获取该设备的MAC地址
	sp.adhandle = adhandle2;
	sp.ip = ip_addr;
	sp.mac = ip_mac;
	sp.netmask = ip_netmask;
	gp.adhandle = adhandle2;
	sendthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) SendArpPacket,
			&sp, 0, NULL);
	recvthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) GetLivePC, &gp,
			0, NULL);
	while (!scanFinished) {
		Sleep(1000);
	}

	for(int j=0;j<countMachine;j++){
		if(Machines[j].IP[0]==192&&Machines[j].IP[1]==168&&Machines[j].IP[2]==191&&Machines[j].IP[3]==191){
			cMacIP=j;break;
		}
	}

	printf("\n--------Going to router--------\n");


	sendHello();

	/* 释放设备列表 */
	pcap_freealldevs(alldevs);

	return 0;
}

void receiveMessage() {
	/* 开始捕获 */
	int ret;
	struct pcap_pkthdr *header;
	const u_char *pkt_data;
	boolean getit = false;
	while ((ret = pcap_next_ex(adhandle, &header, &pkt_data)) >= 0 && (!getit)) {
		if (ret == 0) {
			/* 超时时间到 */
			printf("time over!\n");
			continue;
		}
		char buffer[100];
		if (header->len > 0) {
			printf("len:[%d]n", header->len);
			//获取mac
			rec_eth_head = (ethernet_head*) pkt_data;
			for (int j = 0; j < 6; j++) {
				char * temp = (char*) malloc(sizeof(char));
				_itoa((int) (rec_eth_head->dest_mac_add[j]), temp, 16);
				printf("%s  ", temp);
			}
			printf("DestMac:\n");

			//获取包中的ip
			ip_header *ip = (ip_header *) (pkt_data + 14);
			printf("daddr:[%u.%u.%u.%u]n", ip->daddr.byte1, ip->daddr.byte2,
					ip->daddr.byte3, ip->daddr.byte4);
			//			sourIP=(char *)malloc(sizeof(char*));
			//			strcat(sourIP,ip->daddr.byte1+".");
			//			strcat(sourIP,ip->daddr.byte2+".");
			//			strcat(sourIP,ip->daddr.byte3+".");
			//			strcat(sourIP,ip->daddr.byte4+"");
			//			printf("sourip%s", sourIP);
			printf("saddr:[%u.%u.%u.%u]n", ip->saddr.byte1, ip->saddr.byte2,
					ip->saddr.byte3, ip->saddr.byte4);
			//			destIP=(char *)malloc(sizeof(char*));
			//			strcat(destIP,ip->daddr.byte1+".");
			//			strcat(destIP,ip->daddr.byte2+".");
			//			strcat(destIP,ip->daddr.byte3+".");
			//			strcat(destIP,ip->daddr.byte4+"");

			if (!(ip->daddr.byte1 == 192 && ip->daddr.byte2 == 168
					&& ip->daddr.byte3 == 191 && ip->daddr.byte4 == 1))
				continue;

			tcp_header *tcp = (tcp_header *) ((u_char*) ip
					+ (ip->ver_ihl & 0xf) * 4);

			char *data = (char*) ((char *) tcp + (tcp->hlen) * 4);
			u_int datalen = ntohs(ip->tlen) - (ip->ver_ihl & 0xf) * 4
					- (tcp->hlen) * 4;
			printf("ipheader的长度%d\ntcp头的长度%d\n数据长度%d\n",
					(ip->ver_ihl & 0xf) * 4, (tcp->hlen) * 4, datalen);
			memcpy(buffer, data, datalen);
			memcpy(TcpData, data, datalen);
			printf("buffer:[%s]n", buffer);
			getit = true;

		}
	}

}
void sendHello() {
	memset(&ethernet, 0, sizeof(ethernet));
//	memcpy(ethernet.dest_mac_add, rec_eth_head->source_mac_add, 6);
	BYTE destmac[8];
	destmac[0] = 0x74;
	destmac[1] = 0xe5;
	destmac[2] = 0x0b;
	destmac[3] = 0xf4;
	destmac[4] = 0xbd;
	destmac[5] = 0x07;
	memcpy(ethernet.dest_mac_add, destmac, 6);
	memcpy(ethernet.source_mac_add, selfMAC, 6);
	ethernet.type = htons(0x0800);
	memcpy(&SendBuffer, &ethernet, sizeof(struct ethernet_head));
	ip.Version_HLen = 0x45;
	ip.TOS = 0;
	ip.Length = htons(
			sizeof(struct IpHeader) + sizeof(struct TcpHeader)
					+ strlen(TcpData));
	ip.Ident = htons(1);
	ip.Flags_Offset = 0;
	ip.TTL = 128;
	ip.Protocol = 6;
	ip.Checksum = 0;
	ip.SourceAddr = inet_addr("192.168.1.103");
	ip.DestinationAddr = inet_addr("192.168.191.1");
//	ip.SourceAddr = inet_addr(sourIP);
//	ip.DestinationAddr = inet_addr(destIP);
	memcpy(&SendBuffer[sizeof(struct ethernet_head)], &ip, 20);
	tcp.DstPort = htons(88);
	tcp.SrcPort = htons(1000);
	tcp.SequenceNum = htonl(11);
	tcp.Acknowledgment = 0;
	tcp.HdrLen = 0x50;
	tcp.Flags = 0x18;
	tcp.AdvertisedWindow = htons(512);
	tcp.UrgPtr = 0;
	tcp.Checksum = 0;
	memcpy(&SendBuffer[sizeof(struct ethernet_head) + 20], &tcp, 20);
	ptcp.SourceAddr = ip.SourceAddr;
	ptcp.DestinationAddr = ip.DestinationAddr;
	ptcp.Zero = 0;
	ptcp.Protcol = 6;
	ptcp.TcpLen = htons(sizeof(struct TcpHeader) + strlen(TcpData));

	char TempBuffer[65535];
	memcpy(TempBuffer, &ptcp, sizeof(struct PsdTcpHeader));
	memcpy(TempBuffer + sizeof(struct PsdTcpHeader), &tcp,
			sizeof(struct TcpHeader));
	memcpy(TempBuffer + sizeof(struct PsdTcpHeader) + sizeof(struct TcpHeader),
			TcpData, strlen(TcpData));
	tcp.Checksum = checksum((USHORT*) (TempBuffer),
			sizeof(struct PsdTcpHeader) + sizeof(struct TcpHeader)
					+ strlen(TcpData));

	memcpy(SendBuffer + sizeof(struct ethernet_head) + sizeof(struct IpHeader),
			&tcp, sizeof(struct TcpHeader));
	memcpy(
			SendBuffer + sizeof(struct ethernet_head) + sizeof(struct IpHeader)
					+ sizeof(struct TcpHeader), TcpData, strlen(TcpData));
	memset(TempBuffer, 0, sizeof(TempBuffer));
	memcpy(TempBuffer, &ip, sizeof(struct IpHeader));
	ip.Checksum = checksum((USHORT*) (TempBuffer), sizeof(struct IpHeader));
	memcpy(SendBuffer + sizeof(struct ethernet_head), &ip,
			sizeof(struct IpHeader));
	Result = pcap_sendpacket(adhandle2, SendBuffer,
			sizeof(struct ethernet_head) + sizeof(struct IpHeader)
					+ sizeof(struct TcpHeader) + strlen(TcpData));
	printf("The length is %d\n",
			sizeof(struct ethernet_head) + sizeof(struct IpHeader)
					+ sizeof(struct TcpHeader) + strlen(TcpData));
	if (Result != 0) {
		printf("Send Error!\n");
	} else {
		printf("Send TCP Packet.\n");
		printf("Dstination Port:%d\n", ntohs(tcp.DstPort));
		printf("Source Port:%d\n", ntohs(tcp.SrcPort));
		printf("Sequence:%d\n", ntohl(tcp.SequenceNum));
		printf("Acknowledgment:%d\n", ntohl(tcp.Acknowledgment));
		printf("Header Length:%d*4\n", tcp.HdrLen >> 4);
		printf("Flags:0x%0x\n", tcp.Flags);
		printf("AdvertiseWindow:%d\n", ntohs(tcp.AdvertisedWindow));
		printf("UrgPtr:%d\n", ntohs(tcp.UrgPtr));
		printf("Checksum:%u\n", ntohs(tcp.Checksum));
	}

	printf("\n\n************************\nSend to C message successfully!");
	getchar();
	getchar();
}
/* 获取可用信息*/
void ifget(pcap_if_t *d, char *ip_addr, char *ip_netmask) {
	pcap_addr_t *a;
	char ip6str[128];
	/* IP addresses */
	for (a = d->addresses; a; a = a->next) {
		switch (a->addr->sa_family) {
		case AF_INET:
			if (a->addr) {
				char *ipstr;
				ipstr = iptos(
						((struct sockaddr_in *) a->addr)->sin_addr.s_addr); //*ip_addr
				memcpy(ip_addr, ipstr, 16);
			}
			if (a->netmask) {
				char *netmaskstr;
				netmaskstr = iptos(
						((struct sockaddr_in *) a->netmask)->sin_addr.s_addr);

				memcpy(ip_netmask, netmaskstr, 16);
			}
		case AF_INET6:
			break;
		}
	}
}

/* 向局域网内所有可能的IP地址发送ARP请求包线程 */
DWORD WINAPI SendArpPacket(LPVOID lpParameter) //(pcap_t *adhandle,char *ip,unsigned char *mac,char *netmask)
		{
	sparam *spara = (sparam *) lpParameter;
	pcap_t *adhandle = spara->adhandle;
	char *ip = spara->ip;
	unsigned char *mac = spara->mac;
	char *netmask = spara->netmask;
	printf("ip_mac:%02x-%02x-%02x-%02x-%02x-%02x\n", mac[0], mac[1], mac[2],
			mac[3], mac[4], mac[5]);
	printf("自身的IP地址为:%s\n", ip);
	printf("地址掩码NETMASK为:%s\n", netmask);
	printf("\n");
	unsigned char sendbuf[42]; //arp包结构大小
	struct ethernet_head eh;
	struct arp_head ah;
	memset(eh.dest_mac_add, 0xff, 6); //目的地址为全为广播地址
	memcpy(eh.source_mac_add, mac, 6);
	memcpy(ah.source_mac_add, mac, 6);
	memset(ah.dest_mac_add, 0x00, 6);
	eh.type = htons(ETH_ARP);
	ah.hardware_type = htons(ARP_HARDWARE);
	ah.protocol_type = htons(ETH_IP);
	ah.hardware_add_len = 6;
	ah.protocol_add_len = 4;
	ah.source_ip_add = inet_addr(ip); //请求方的IP地址为自身的IP地址
	ah.operation_field = htons(ARP_REQUEST);
	//向局域网内广播发送arp包
	unsigned long myip = inet_addr(ip);
	unsigned long mynetmask = inet_addr(netmask);
	unsigned long hisip = htonl((myip & mynetmask));
	for (int i = 0; i < HOSTNUM; i++) {
		ah.dest_ip_add = htonl(hisip + i);
		memset(sendbuf, 0, sizeof(sendbuf));
		memcpy(sendbuf, &eh, sizeof(eh));
		memcpy(sendbuf + sizeof(eh), &ah, sizeof(ah));
		if (pcap_sendpacket(adhandle, sendbuf, 42) == 0) {
			//printf("\nPacketSend succeed\n");
		} else {
			printf("PacketSendPacket in getmine Error: %d\n", GetLastError());
		}
		Sleep(50);
	}
	Sleep(1000);
	flag = TRUE;
	return 0;
}
/* 分析截留的数据包获取活动的主机IP地址 */
DWORD WINAPI GetLivePC(LPVOID lpParameter) //(pcap_t *adhandle)
		{
	gparam *gpara = (gparam *) lpParameter;
	pcap_t *adhandle = gpara->adhandle;
	int res;
	unsigned char Mac[6];
	struct pcap_pkthdr * pkt_header;
	const u_char * pkt_data;

	while (true) {
		if (flag) {
			printf("扫描完毕，按任意键退出!\n");
			scanFinished = true;
			break;
		}
		if ((res = pcap_next_ex(adhandle, &pkt_header, &pkt_data)) >= 0) {
			if (*(unsigned short *) (pkt_data + 12) == htons(ETH_ARP)) {
				struct arp_packet *recv = (arp_packet *) pkt_data;
				if (*(unsigned short *) (pkt_data + 20) == htons(ARP_REPLY)) {
					printf("-------------------------------------------\n");
					Machines[countMachine].IP[0] = recv->ah.source_ip_add & 255;
					Machines[countMachine].IP[1] = recv->ah.source_ip_add >> 8
							& 255;
					Machines[countMachine].IP[2] = recv->ah.source_ip_add >> 16
							& 255;
					Machines[countMachine].IP[3] = recv->ah.source_ip_add >> 24
							& 255;
					printf("序号：%d	IP地址:%d.%d.%d.%d   MAC地址:", countMachine,
							recv->ah.source_ip_add & 255,
							recv->ah.source_ip_add >> 8 & 255,
							recv->ah.source_ip_add >> 16 & 255,
							recv->ah.source_ip_add >> 24 & 255);
					for (int i = 0; i < 6; i++) {
						Mac[i] = *(unsigned char *) (pkt_data + 22 + i);
						Machines[countMachine].Mac[i] = Mac[i];
//					printf("%u",Machines[countMachine].Mac[i]);
						printf("%02x", Mac[i]);
					}
					countMachine++;
					printf("\n");
				}
			}

		}

		Sleep(10);
	}
	scanFinished=true;


	return 0;
}
/* 获取自己主机的MAC地址
 广播一个arp包，如果接收到的包的源ip是自己设定的那个， 那么就是自己的包，那么，从这个包里可以找到自己的mac

 */
int GetSelfMac(pcap_t *adhandle, const char *ip_addr, unsigned char *ip_mac) {
	unsigned char sendbuf[42];            //arp包结构大小
	int i = -1;
	int res;
	struct ethernet_head eh;
	struct arp_head ah;
	struct pcap_pkthdr * pkt_header;
	const u_char * pkt_data;
	memset(eh.dest_mac_add, 0xff, 6);            //目的地址为全为广播地址
	memset(eh.source_mac_add, 0x0f, 6);
	memset(ah.source_mac_add, 0x0f, 6);
	memset(ah.dest_mac_add, 0x00, 6);
	eh.type = htons(ETH_ARP);
	ah.hardware_type = htons(ARP_HARDWARE);
	ah.protocol_type = htons(ETH_IP);
	ah.hardware_add_len = 6;
	ah.protocol_add_len = 4;
	ah.source_ip_add = inet_addr("100.100.100.100"); //随便设的请求方ip
	ah.operation_field = htons(ARP_REQUEST);
	ah.dest_ip_add = inet_addr(ip_addr);

	memset(sendbuf, 0, sizeof(sendbuf));
	memcpy(sendbuf, &eh, sizeof(eh));
	memcpy(sendbuf + sizeof(eh), &ah, sizeof(ah));
	if (pcap_sendpacket(adhandle, sendbuf, 42) == 0) {
		printf("\nPacketSend succeed\n");
	} else {
		printf("PacketSendPacket in getmine Error: %d\n", GetLastError());
		return 0;
	}
	while ((res = pcap_next_ex(adhandle, &pkt_header, &pkt_data)) >= 0) {
		if (*(unsigned short *) (pkt_data + 12) == htons(ETH_ARP)
				&& *(unsigned short*) (pkt_data + 20) == htons(ARP_REPLY)
				&& *(unsigned long*) (pkt_data + 38)
						== inet_addr("100.100.100.100")) {
			for (i = 0; i < 6; i++) {
				ip_mac[i] = *(unsigned char *) (pkt_data + 22 + i);
				selfMAC[i] = ip_mac[i];
			}
			printf("获取自己主机的MAC地址成功!\n");
			break;
		}
	}
	if (i == 6) {
		return 1;
	} else {
		return 0;
	}
}

/* 将数字类型的IP地址转换成字符串类型的*/
char *iptos(u_long in) {
	static char output[IPTOSBUFFERS][3 * 4 + 3 + 1];
	static short which;
	u_char *p;
	p = (u_char *) &in;
	which = (which + 1 == IPTOSBUFFERS ? 0 : which + 1);
	sprintf(output[which], "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
	return output[which];
}
char* ip6tos(struct sockaddr *sockaddr, char *address, int addrlen) {
	socklen_t sockaddrlen;
#ifdef WIN32
	sockaddrlen = sizeof(struct sockaddr_in6);
#else
	sockaddrlen = sizeof(struct sockaddr_storage);
#endif

	if (getnameinfo(sockaddr, sockaddrlen, address, addrlen,
	NULL, 0, NI_NUMERICHOST) != 0)
		address = NULL;
	return address;
}
